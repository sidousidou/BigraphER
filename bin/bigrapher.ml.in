open Printf
open Utils
open Syntax

let version = "@PACKAGE_VERSION@"
  
let verbose_bool = ref false

let version_bool = ref false
  
let model_str = ref ""

let consts_str = ref ""
  
let properties_str = ref ""
  
let export_trans_str = ref ""

let export_csl_str = ref ""
  
let export_trans_dot_str = ref ""
  
let export_store = ref ""
  
let export_states_bool = ref false
  
let sim_bool = ref false
  
let t_max = ref 100.0
  
let s_max = ref 10000
  
let usage =
  "Usage: bigrapher [options] <model-file> [<properties-file>] [more-options]"

let speclist =
  [ ("-v", (Arg.Unit (fun () -> verbose_bool := true)), " Verbose output");
    ("-V", (Arg.Unit (fun () -> version_bool := true)), " Program version");
    ("-t", (Arg.Float (fun t -> t_max := t)),
     "<float> Set the termination time of the simulation");
    ("-max", (Arg.Int (fun n -> s_max := n)),
     "<int> Set the maximum number of states");
    ("-sim", (Arg.Unit (fun () -> sim_bool := true)), " Simulate the model");
    ("-exporttrans", (Arg.String (fun s -> export_trans_str := s)),
     "<file> Export the transition system to a file");
    ("-exportdot", (Arg.String (fun s -> export_trans_dot_str := s)),
     "<path> Export the transition system to a dot file");
    ("-exportstates", (Arg.Unit (fun () -> export_states_bool := true)),
     " Export each state to a file");
    ("-exportcsl", (Arg.String (fun s -> export_csl_str := s)),
     "<file> Export the labelling function to a file"); 
    ("-exportstore", (Arg.String (fun s -> export_store := s)),
     "<path> Export each bigraph in the store to a dot file");
    ("-consts", (Arg.String (fun s -> consts_str := s)),
     "<ide=val, ...> Specify constants") ]

let print_version () = 
  printf "BigraphER %s\n" version

let print_header () =
  printf "\n\
          %s\n\
          ========================================\n\
          %s      %s\n\
          %s         %s\n\
          %s     %s\n\
          %s      %s\n\
          %s %s\n"
    (colorise `bold "BigraphER: Bigraph Evaluator & Rewriting")
    (colorise `magenta "Version:") (String.trim version) 
    (colorise `magenta "Date:") (format_time ()) 
    (colorise `magenta "Hostname:") (Unix.gethostname ()) 
    (colorise `magenta "OS type:") Sys.os_type
    (colorise `magenta "Command line:")  (String.concat " " (Array.to_list Sys.argv))

let print_stats_store env stoch t0 =
  let t = (Unix.gettimeofday ()) -. t0 
  and ty = if stoch then "Stochastic BRS" else "BRS" in
  printf "%s   %-4g s\n\
          %s         %s\n\
          %s     %d\n"
    (colorise `cyan "Build time:") t
    (colorise `cyan "Type:") ty
    (colorise `cyan "Bindings:") (Hashtbl.length env)

let print_loop v_flag i _ = 
  if v_flag then printf "\r%3d states found%!" (i + 1)
  else () 

(* Raise Sys_error if the file could not be opened *)
let open_lex path = 
  let file = open_in path in
  let lexbuf = Lexing.from_channel file in
  lexbuf.Lexing.lex_curr_p <-
    { Lexing.pos_fname = Filename.basename path;
      Lexing.pos_lnum = 1;
      Lexing.pos_bol = 0;
      Lexing.pos_cnum = 0;
    };
  (lexbuf, file)          

let _ =
  try
    Printexc.record_backtrace true;
    Export.check_graphviz ();
    Arg.parse (Arg.align speclist) (fun filename ->
        if Filename.check_suffix filename "big" then 
	  model_str := filename
        else if Filename.check_suffix filename "bilog" then 
	  properties_str := filename
        else raise (Arg.Bad ((colorise `red "Bad argument: ") ^ filename))
      ) usage;
    if !version_bool then print_version ()
    else begin 
      let iter_f = print_loop true in
      print_header ();
      let (decs, brs) =
	if !model_str = "" then 
          raise (Arg.Bad ((colorise `red "Error: ") ^ "Model file missing.\n" ^ usage))
        else begin
	  print_string ((colorise `yellow "Parsing model file ") ^ 
                          (colorise `bold (colorise `yellow !model_str)) ^
                          (colorise `yellow "...\n")); 
	  let lexbuf, file = open_lex !model_str in
	  let out = Parser_main.model Lexer_main.lex lexbuf in 
	  close_in file; 
	  out
	end in
      let t0 = Unix.gettimeofday () in
      printf "%s\n" (colorise `yellow "Building model...");
      let env = Store.init_env decs in
      Store.parse_consts !consts_str env;
      Store.store_decs decs env;
      let (s0, stoch, p_classes) =
	Store.store_brs brs env in
      if !export_store <> "" then
	Store.export decs env !export_store !verbose_bool;
      print_stats_store env stoch t0;
      let p = Store.dummy_pos  
      and n = Hashtbl.length env in
      if not stoch then begin
	let brs_p_classes = List.map Store.p_to_brs p_classes 
	and get_f = Store.get_react p env in
        let (ts, stats) = 
          if !sim_bool then
            Brs.sim_ide s0 brs_p_classes get_f !s_max n iter_f
          else
            Brs.bfs_ide s0 brs_p_classes get_f !s_max n iter_f in
        print_stats stats.Brs.t stats.Brs.s stats.Brs.r stats.Brs.o; 
        if !export_trans_dot_str <> "" then begin
          if !export_states_bool then
            Brs.iter_states (fun i s ->
	        Export.write_big s (string_of_int i) !export_trans_dot_str
	          !verbose_bool) ts;
          Export.write_ts ts "ts" !export_trans_dot_str !verbose_bool
        end;
        if !export_trans_str <> "" then 
	  Export.write_ts_prism ts "ts_prism" !export_trans_str !verbose_bool;
	if !export_csl_str <> "" then
	  Export.write_csl ts.Brs.l "properties.csl" !export_csl_str !verbose_bool;
      end else begin
	let sbrs_p_classes = List.map Store.p_to_sbrs p_classes 
	and get_f = Store.get_sreact p env in
	let (ctmc, stats) = 
	  if !sim_bool then
	    Sbrs.sim_ide s0 sbrs_p_classes get_f !t_max n iter_f
          else
            Sbrs.bfs_ide s0 sbrs_p_classes get_f !s_max n iter_f in
        print_stats stats.Sbrs.t ~sim:stats.Sbrs.sim stats.Sbrs.s stats.Sbrs.r stats.Sbrs.o; 
	if !export_trans_dot_str <> "" then begin
	  if !export_states_bool then
	    Sbrs.iter_states (fun i s ->
	        Export.write_big s (string_of_int i) !export_trans_dot_str
		  !verbose_bool) ctmc;
	  Export.write_ctmc ctmc "ctmc" !export_trans_dot_str !verbose_bool
	end;
	if !export_trans_str <> "" then
	  Export.write_ctmc_prism ctmc "ctmc_prism" !export_trans_str !verbose_bool;
	if !export_csl_str <> "" then
	  Export.write_csl ctmc.Sbrs.l "properties.csl" !export_csl_str !verbose_bool;
      end;
    end
  with
  | Arg.Bad m -> 
    prerr_endline m; exit 1 
  | Parsing.Parse_error ->
    prerr_endline (colorise `red "Parsing unsuccesful"); 
    exit 1
  | Store.INVALID_CONSTS | Store.INVALID_VAL | Store.WRONG_TYPE 
  | Store.NO_IDE | Store.INVALID_PRI -> 
    exit 1
  | Link.FACES_MISMATCH (inner, outer) ->
    eprintf "%sImpossible to compose over faces:\n\
            \       %s\n\
            \       %s\n" 
      (colorise `red "Error: ")
      (Link.string_of_face inner) (Link.string_of_face outer); 
    exit 1
  | Link.NAMES_ALREADY_DEFINED (inner, outer) ->
    eprintf "%sDuplicate inner names: %s\n\
            \       Duplicate outer names: %s\n"
      (colorise `red "Error: ")
      (Link.string_of_face inner) (Link.string_of_face outer); 
    exit 1
  | Place.COMP_ERROR (sites, roots) ->
    eprintf "%sImpossible to compose with %d sites and %d regions\n"
      (colorise `red "Error: ")
      sites roots;
    exit 1
  | Big.SHARING_ERROR -> 
    eprintf "%sInvalid sharing expression\n"    
      (colorise `red "Error: "); 
    exit 1
  | Big.CTRL_ERROR (n, face) ->
    eprintf "%sImpossible to use face %s with a control of arity %d\n" 
      (colorise `red "Error: ")
      (Link.string_of_face face) n;
    exit 1
  | Big.ISO_ERROR (n, n_dom) ->
    eprintf "%sIsomorphism is not total: (%d < %d)\n"
      (colorise `red "Error: ")
      n_dom n;
    exit 1
  | e -> 
    eprintf "%s\n%s" (Printexc.to_string e) (Printexc.get_backtrace ()); exit 1
